# JVMのアーキテクチャ
JVMのアーキテクチャはクラス・ローダー・サブシステムから始まる様々なコンポーネントで構成されている

*クラス・ローダー・サブシステム*
→Javaの.classファイルをメモリにロードする役割を担っている

*メモリ領域*
* メソッド領域
* ヒープ領域
* スタック領域
* PCレジスタ
* ネイティブメソッドスタック

*実行エンジン*
→Javaプログラムを実行するためのコンポーネント

## Class Loaders
クラスローダーはデリゲーションモデルに従う

1. VMがアプリケーション・クラスに出会ったとき、まずそのクラスがすでにメソッド領域にあるかどうかをチェックし、なければクラス・ローダー・システムにクラスをロードするよう依頼する
2. アプリケーション・クラスローダーは、要求をエクステンション・クラスローダーに委譲し、エクステンション・クラスローダーはブートストラップ・クラスローダーに要求する
3. この時点で、階層の最上位にあるブートストラップ・クラスローダは、 jre/lib/*.jar であるブートストラップ・クラスパスをチェックする。もしクラスがそこにあれば、それをロードし、クラスがなければ、要求をエクステンション・クラスローダーに委譲する
4. Extension Classloaderは、ext/*.jarをチェックし、クラスがあれば、それをメモリにロードする。なければアプリケーション・クラスローダーに移譲する
5. 最後に、リクエストがアプリケーションクラスローダに委譲されると、アプリケーションクラスローダはアプリケーションクラスパスとその下のjar（jdbc.jar, hibernate.jar）をチェックし、クラスがあればそれらをロードする
6. もし見つからなければ、NoClassDefFoundExceptionかClassNotFoundExceptionをランタイムに投げることになる。

クラス・ローダー・システムは３種類のクラス・ローダーで構成されている

*ブートストラップ・クラス・ローダー*
JDK/JRE/libフォルダの下のrt.jarの中にあるクラス（JDKのインストールに付属するAPIクラス→全てのJavaプログラムで使用することができるライブラリ）をロードする
このクラスローダーは全てのJavaインストールに付属している

*エクステンション・クラス・ローダー*
JDK/JRE/libのextフォルダーからクラスをロードする（security.jar, JDBC.jarなど）
クラスはsun.misc.Launcher$ExtClassLoader.class

*アプリケーション・クラス・ローダー*
クラスパスの環境変数に置いた、アプリケーション・クラス（作成したクラス）を全てロードする
クラスはsun.misc.Launcher$ApplicationClassLoader.class

```
package classloading;


public class User {

	public String getName() {
		return "Bharath";
	}

	public String getEmail() {
		return "bharath@gmail.com";
	}
}

```

Userクラスの情報を動的にメモリにロードして、情報を取得する
```
package classloading;

import java.lang.reflect.Method;

public class Test {
	// クラスを動的にメモリにロードし、その情報を取得する
	public static void main(String[] args) throws ClassNotFoundException {
		/*
		 * 引数でクラス名を受け取り、それをメモリにロードする。 クラスが見つからなければ例外を投げる
		 */
		Class c = Class.forName("User");

		// getDeclaredMethods()：メソッドの配列を返す(今回はUserクラスで定義したメソッド)
		Method[] methods = c.getDeclaredMethods();

		for (Method method : methods) {
			// getName(): メソッド名を取得する
			System.out.println(method.getName());
		}
		System.out.println(methods.length);

	}

}

```

```
package classloading;

public class MultipleObjects {

	public static void main(String[] args) {

		User u1 = new User();
		Class c1 = u1.getClass();

		User u2 = new User();
		Class c2 = u2.getClass();

		/*
		 * u1とu2のhashcodeは同一 →アプリケーションで特定のクラスを何度使っても、クラス自体は一度だけメモリにロードされる
		 */
		System.out.println(c1.hashCode());
		System.out.println(c2.hashCode());
		System.out.println(c1 == c2);
		// このクラス(c1)を読み込んでいるクラスローダーの情報を表示する
		// →アプリケーションクラスローダーで読み込んでいることがわかる
		System.out.println(c1.getClassLoader());
	}

}

```


## クラス・ローディング・サブシステム
JVMアーキテクチャの１つで、以下の３つの役割を持つ
1. ロード
2. リンク
3. 初期化

### ロードについて
ロードとは、ハードディスクから.classファイル（上記したUser.classファイルなど）を読み込んで、そのバイナリ情報またはデータをJVMのメソッド領域に格納すること<br>
→JVMは全てのクラスファイルをロードする

メソッド領域に格納される情報は
* 完全修飾クラス名
*  完全修飾親クラス名
* メソッド情報
* 変数情報
* コンストラクター情報
* モディファイア情報
* コンスタント・プール情報
がある

.classファイルがメソッド領域にロードされると、JVMはヒープ領域にロードされたクラスのオブジェクトを作成する
→これらのオブジェクトにはjava.lang.Classを使ってアクセスすることができる

### リンクについて
リンクは3つの活動に細分される
1. 検証
2. 準備
3. 解決

*検証*
メソッド領域内のクラス・ファイルのバイナリ表現が正しく、破損していないことを確認するプロセス
→この確認をbyte code verifierが行う問題がある場合は、java.lang.VerifyErorrをスローする

*準備*
JVMが全ての静的変数または、クラスレベル変数のためのメモリを割り当て、データ型に基づいてデフォルト値を割り当てる

*解決*
メソッド領域でシンボリック名をオリジナルのメモリ参照に置き換えるプロセス

### 初期化について
静的変数に割り当てた値で静的変数を初期化する
また、親クラスから子クラス、上から下へと全てのスタティックブロックを実行する

## メソッド領域
クラスがメモリにロードされると、全てのクラスレベルのバイナリ情報はメソッドエリアに格納される
→これはランタイム・コンスタント・プールである
この領域は複数のスレッドで共有され、メソッド領域はJVMが起動した時にすぐに作成される

## スタック領域
JVMによってスレッドが作成されると、そのためのスタックも作成される。全てのメソッドコールとローカル変数はこのスタックに格納される
→各スレッドは独自のスタック領域を取得する。他のスレッドにはアクセスすることはできない

### スタックフレーム
スレッドが呼び出す各メソッドにはスタックフレームがある
スタックフレームは３つの部分を持っている
1. ローカル変数配列
2. オペランドスタック
3. フレームデータ

*ローカル変数配列*
メソッドの全てのパラメータとローカル変数が格納される。

*オペランドスタック*
JVMはここをワークスペースとして演算を行う。

*フレームデータ*
constant pool情報が格納されている。また、Exceptionテーブルへの参照も含まれている
→例外が発生したときに、それに対応するキャッチブロックの情報を提供する

## ヒープ領域
アプリケーションで作成される全てのオブジェクトは、ヒープ領域に格納される
